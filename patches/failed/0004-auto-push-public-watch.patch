diff --git a/tools/patch_agent/watch_patches.py b/tools/patch_agent/watch_patches.py
--- a/tools/patch_agent/watch_patches.py
+++ b/tools/patch_agent/watch_patches.py
@@ -8,11 +8,27 @@
 ROOT = Path(__file__).resolve().parents[2]
 INCOMING = ROOT / "patches" / "incoming"
 APPLY = Path(__file__).resolve().parent / "apply_patch.py"
 
 def run(cmd, cwd=None):
     print(">>", " ".join(cmd))
     return subprocess.run(cmd, cwd=cwd, text=True)
 
+def has_remote(name: str) -> bool:
+    """Return True if a Git remote with the given name exists."""
+    try:
+        p = subprocess.run(["git", "remote"], cwd=ROOT, capture_output=True, text=True)
+        out = p.stdout or ""
+        names = [line.strip() for line in out.splitlines()]
+        return name in names
+    except Exception:
+        return False
+
+def auto_push_public():
+    if has_remote("public"):
+        print("[Watcher] Auto-push to 'public'...")
+        r = run(["git", "push", "public", "HEAD"], cwd=ROOT)
+        if r.returncode != 0:
+            print("[Watcher] Auto-push failed (non-zero exit)." )
+    else:
+        print("[Watcher] Remote 'public' not found; skipping auto-push.")
+
 def wait_for_complete(file_path, timeout=10):
     """Wait until file size stops changing (fully written)"""
     last_size = -1
     stable_count = 0
     start_time = time.time()
@@ -39,7 +55,11 @@
         if p.is_file() and p.suffix.lower() == ".patch":
             if wait_for_complete(p):
                 print(f"[Watcher] New patch: {p.name}")
-                run([sys.executable, str(APPLY), str(p)], cwd=ROOT)
+                result = run([sys.executable, str(APPLY), str(p)], cwd=ROOT)
+                # Auto-push only if apply succeeded
+                try:
+                    if result and getattr(result, "returncode", 1) == 0:
+                        auto_push_public()
+                except Exception:
+                    pass
             else:
                 print(f"[Watcher] Timeout waiting for {p.name} to finish writing.")
 
 def main():
     INCOMING.mkdir(parents=True, exist_ok=True)
